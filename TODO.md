- peri を連結する時に、できるだけ近くどうしを組みあわせてからまないようにできないものか。失敗確率が高すぎる。
  - Dijkstra で最短でつないでしまうという手もあるな。
  - loop をどんどん release してしまうという手もある。
  - 逐次的に相手をさがすのではなく、最初にぜんぶ対応を計画するのが良いと思う。

現状で「解が 1 つ見つかれば良い」にもかかわらず、高確率で探索がブロックされてしまうとのこと、お困りですね。特に「遠い白ノードと黒ノードをつないでしまっている」という点が原因として考えられるのであれば、より「近い」マッチングを優先的に探索するアルゴリズムが有効です。

最適解を求める必要がないのであれば、以下のアルゴリズムが問題解決に役立つ可能性があります。

# 反復深化深さ優先探索 (Iterative Deepening Depth-First Search: IDDFS)

これは、深さ優先探索 (DFS) と幅優先探索 (BFS) の利点を組み合わせた探索アルゴリズムです。
考え方: 探索の深さ制限を 1 から順に増やしながら、深さ優先探索を行います。例えば、まず深さ 1 までのパスを探し、見つからなければ深さ 2 まで、というように探索範囲を広げていきます。

## 利点:

- 最短パスの優先: 深さ制限があるため、自然と「短い」パス（つまり、近い白ノードと黒ノード間のパス）から先に探索されます。これにより、現状の問題点である「遠いノードをつないでしまう」ことを避け、リソース（ノードやエッジ）の消費を最小限に抑え、他のマッチングの可能性をブロックしにくくなります。
- メモリ効率: 深さ優先探索がベースなので、幅優先探索に比べて必要なメモリ量が少なくて済みます。
- 解の保証: もし解が存在すれば、必ず見つけることができます。

## この問題への適用:

- まず、すべての白ノードと黒ノードのペアについて、それぞれの間の最短パスを計算します（例えば、BFS を使用）。
- IDDFS で、深さ制限を設けてマッチングパスを探索します。見つかったパスでマッチングを行い、そのノードとエッジをグラフから削除（または使用済みとしてマーク）します。
- 残りのノードとグラフで、再度 IDDFS を適用して次のマッチングを探します。これを、すべての白ノードがマッチングされるか、これ以上マッチングが見つからなくなるまで繰り返します。
